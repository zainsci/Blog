<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preload" href="fonts.googleapis.com"/><title>Day 43 - Learning Regular Expressions - zainsci-blog</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:title" content="zainsci-blog"/><meta property="og:description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:image" content="https://zainsci.github.io/potrait.jpg"/><meta property="og:url" content="https://zainsci.github.io/blog"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site_name" content="zainsci-blog"/><meta name="twitter:image:alt" content="zainsci&#x27;s portrait"/><meta name="next-head-count" content="13"/><link rel="preload" href="/blog/_next/static/css/84d451ea0fea089d896b.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/84d451ea0fea089d896b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-08bb45713b568a3c61e0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-03337388e7702cb579d9.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-124259c81ad6abc14284.js" as="script"/></head><body><div id="__next"><header class="header"><div><h3 class="logo">zainsci-blog</h3><div class="nav__toggler"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div></div><nav class="nav"><ul class="nav__list"><li class="nav__item"><a class="nav__link" href="/blog">Home</a></li><li class="nav__item"><a href="https://zainsci.github.io" class="nav__link" target="_blank" rel="noopener noreferrer">Portfolio</a></li><li class="nav__item"><a class="nav__link" href="/blog/about">About</a></li><li class="nav__item"><a class="nav__link" href="/blog/contact">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><a class="skip-link" href="#main">Skip to main</a><main id="main"><article class="article" itemscope="" itemType="http://schema.org/Article"><div class="share"><p>Share</p><div class="share__buttons"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-43&amp;text=Day 43 - Learning Regular Expressions
&amp;hashtags=zainsci,Linux" target="_blank" rel="noreferrer" class="share__button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-43" target="_blank" rel="noreferrer" class="share__button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div><header class="article__header"><h1 itemProp="headline">Day 43 - Learning Regular Expressions</h1><div itemProp="datePublished">2021-02-12</div></header><section itemProp="articleBody" class="article__body"><p>There is this command called <code>grep</code> that I wrote about in <a href="/day-36/">Day 36</a>. It is used to find all the matches of a given text or regex from the given text file or from the output of some other command. If a single word like <code>email</code> is typed as the argument to grep it will only look got that word and nothing more but that is not helpful at all when you want to search for text that you don't even know what it is or looks like. For example you want to find all the emails from a large text and some have .edu or other domain in front of them then it will be very difficult to extract all the emails from that file without lossing some.</p>
<p>Thats where Regular Expressions or regex comes to help. Regular Expressions are used to look for patterns in a large text and extract them. <code>grep</code> uses regex to find all the text that matches the regex pattern. In case of searching for emails using regex will make them easily extractable because all emails follow a same pattern, emailname@provider.topleveldomain.</p>
<h2>What Are Regular Expressions?</h2>
<p>Regular Expressions or more easy to read regex are sequence of characters that define a search pattern to find text from a large files of text. The concept of regex is as old as the FORTRAN Programming Language or maybe older.</p>
<p>Regex is mostly used to validate user data and search through a lrage body of text. A simple use case is validating emails when signing up or logging in to a website and the website checks if the entered emails follows the pattern.</p>
<h2>Regex Syntax</h2>
<p>I will be using grep command to look for patterns in the text of my post of Day36 and will do regex with examples.</p>
<h3>Matching Words</h3>
<p>First I will look for all the words that have "th" at the end of the word in the text file called day36.txt using grep and later will explain the pattern that I wrote to do so. To write the regex in the grep use double quotes and write the expression in them.</p>
<pre><code class="language-bash">root@User:~$ grep "[a-zA-Z]*th " day36.txt
with
path
fifth
</code></pre>
<p>This is read like this: One or more characters (<code>*</code>) that are between the range <code>a to z</code> and <code>A to Z</code> (<code>[a-zA-Z]</code>) followed by <code>th</code> and a single space.</p>
<ul>
<li><strong><code>[]</code></strong> Mathces a single character from the characters that are inside the brackets
If I only add a inside the brackets like this <code>[a]</code> it will only look for a single <code>a</code></li>
<li><strong><code>*</code></strong> Asterisk after the brackets matches one or more character that are inside the brackets</li>
<li><strong><code>a-z</code></strong> This means match characters between <code>a</code> to <code>z</code>.</li>
<li><strong><code>A-Z</code></strong> This means match characters between <code>A</code> to <code>Z</code>.</li>
</ul>
<p>Now if I replace <code>th</code> with <code>l</code> follwing will be the output.</p>
<pre><code class="language-bash">root@User:~$ grep "[a-zA-Z]*l " day36.txt
will
all
useful
peaceful
terminal
</code></pre>
<p>All the letters ending with <code>l</code>.</p>
<h3>Searching For Domains</h3>
<p>This expression will look for all the domain names inside the text file.</p>
<pre><code class="language-bash">root@User:~$ grep "^[a-zA-Z0-9]*\.[a-zA-Z0-9]*" day36.txt
wikipedia.com
google.com
wikimedia.org
github.com
zainsci.github.io/blog
another.blah
newfile.txt
some.com.au.aus.australia
wikipedia.com
google.com
github.com
some.com.au.aus.australia
zainsci.github.io/blog
zainsci.github.io/blog
</code></pre>
<p>You see that it will not inclue <code>fake-site.com</code> in the results because <code>-</code> inside the brackets is a special character and to include the special characters to search for you have to escape them like I did for <code>.</code> in the expression.</p>
<ul>
<li><strong><code>^</code></strong> This means the starting position of the line</li>
<li><strong><code>\.</code></strong> <code>\</code> (Back Slash) to escape the <code>.</code> (Dot) because dot in regex means any character.</li>
</ul>
<p>So if I didn't excaped the dot the result would have been the full file.</p>
<h3>Not Mathcing Any Letter</h3>
<p>Adding <code>^</code> inside the brackets will cause the expression to look for all the character that does not match the characters inside the brackets</p>
<pre><code class="language-bash">root@User:~$ grep "[^a-zA-Z0-9]" day36.txt
~
.
\
/
(
)
-
</code></pre>
<p>These are all the symbols that are written inside the text file.</p>
<h3>Matching Word Between Mentioned Numbers</h3>
<p>To match words that are in the specifeid length in the text file I will use the following expression.</p>
<pre><code class="language-bash">root@User:~$ grep " [a-z]{5} " day36.txt
fifth
other
about
needs
...
...
</code></pre>
<p>This is like "find all words of length five between a and z"</p>
<ul>
<li><strong><code>{min, max}</code></strong> Curly Brackets define the range of letter to look for</li>
<li><strong><code>{5}</code></strong> = five characters</li>
<li><strong><code>{5, 9}</code></strong> = five to nine characters</li>
<li><strong><code>{5,}</code></strong> = more than five characters</li>
<li><strong><code>{,5}</code></strong> = less or five characters</li>
</ul>
<p>And that's it for now because Regex can be much difficult to learn in one day, SO more of it tomorrow.</p>
</section></article><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div class="social__icons"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><img src="/blog/assets/svgs/twitter.svg" alt="twitter logo"/></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><img src="/blog/assets/svgs/instagram.svg" alt="instagram logo"/></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><img src="/blog/assets/svgs/github.svg" alt="github logo"/></a></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 43 - Learning Regular Expressions","date":"2021-02-12","slug":"day-43","content":"\u003cp\u003eThere is this command called \u003ccode\u003egrep\u003c/code\u003e that I wrote about in \u003ca href=\"/day-36/\"\u003eDay 36\u003c/a\u003e. It is used to find all the matches of a given text or regex from the given text file or from the output of some other command. If a single word like \u003ccode\u003eemail\u003c/code\u003e is typed as the argument to grep it will only look got that word and nothing more but that is not helpful at all when you want to search for text that you don't even know what it is or looks like. For example you want to find all the emails from a large text and some have .edu or other domain in front of them then it will be very difficult to extract all the emails from that file without lossing some.\u003c/p\u003e\n\u003cp\u003eThats where Regular Expressions or regex comes to help. Regular Expressions are used to look for patterns in a large text and extract them. \u003ccode\u003egrep\u003c/code\u003e uses regex to find all the text that matches the regex pattern. In case of searching for emails using regex will make them easily extractable because all emails follow a same pattern, emailname@provider.topleveldomain.\u003c/p\u003e\n\u003ch2\u003eWhat Are Regular Expressions?\u003c/h2\u003e\n\u003cp\u003eRegular Expressions or more easy to read regex are sequence of characters that define a search pattern to find text from a large files of text. The concept of regex is as old as the FORTRAN Programming Language or maybe older.\u003c/p\u003e\n\u003cp\u003eRegex is mostly used to validate user data and search through a lrage body of text. A simple use case is validating emails when signing up or logging in to a website and the website checks if the entered emails follows the pattern.\u003c/p\u003e\n\u003ch2\u003eRegex Syntax\u003c/h2\u003e\n\u003cp\u003eI will be using grep command to look for patterns in the text of my post of Day36 and will do regex with examples.\u003c/p\u003e\n\u003ch3\u003eMatching Words\u003c/h3\u003e\n\u003cp\u003eFirst I will look for all the words that have \"th\" at the end of the word in the text file called day36.txt using grep and later will explain the pattern that I wrote to do so. To write the regex in the grep use double quotes and write the expression in them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eroot@User:~$ grep \"[a-zA-Z]*th \" day36.txt\r\nwith\r\npath\r\nfifth\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is read like this: One or more characters (\u003ccode\u003e*\u003c/code\u003e) that are between the range \u003ccode\u003ea to z\u003c/code\u003e and \u003ccode\u003eA to Z\u003c/code\u003e (\u003ccode\u003e[a-zA-Z]\u003c/code\u003e) followed by \u003ccode\u003eth\u003c/code\u003e and a single space.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/strong\u003e Mathces a single character from the characters that are inside the brackets\r\nIf I only add a inside the brackets like this \u003ccode\u003e[a]\u003c/code\u003e it will only look for a single \u003ccode\u003ea\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/strong\u003e Asterisk after the brackets matches one or more character that are inside the brackets\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ea-z\u003c/code\u003e\u003c/strong\u003e This means match characters between \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003ez\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eA-Z\u003c/code\u003e\u003c/strong\u003e This means match characters between \u003ccode\u003eA\u003c/code\u003e to \u003ccode\u003eZ\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow if I replace \u003ccode\u003eth\u003c/code\u003e with \u003ccode\u003el\u003c/code\u003e follwing will be the output.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eroot@User:~$ grep \"[a-zA-Z]*l \" day36.txt\r\nwill\r\nall\r\nuseful\r\npeaceful\r\nterminal\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAll the letters ending with \u003ccode\u003el\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eSearching For Domains\u003c/h3\u003e\n\u003cp\u003eThis expression will look for all the domain names inside the text file.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eroot@User:~$ grep \"^[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\" day36.txt\r\nwikipedia.com\r\ngoogle.com\r\nwikimedia.org\r\ngithub.com\r\nzainsci.github.io/blog\r\nanother.blah\r\nnewfile.txt\r\nsome.com.au.aus.australia\r\nwikipedia.com\r\ngoogle.com\r\ngithub.com\r\nsome.com.au.aus.australia\r\nzainsci.github.io/blog\r\nzainsci.github.io/blog\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou see that it will not inclue \u003ccode\u003efake-site.com\u003c/code\u003e in the results because \u003ccode\u003e-\u003c/code\u003e inside the brackets is a special character and to include the special characters to search for you have to escape them like I did for \u003ccode\u003e.\u003c/code\u003e in the expression.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e^\u003c/code\u003e\u003c/strong\u003e This means the starting position of the line\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\\.\u003c/code\u003e\u003c/strong\u003e \u003ccode\u003e\\\u003c/code\u003e (Back Slash) to escape the \u003ccode\u003e.\u003c/code\u003e (Dot) because dot in regex means any character.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo if I didn't excaped the dot the result would have been the full file.\u003c/p\u003e\n\u003ch3\u003eNot Mathcing Any Letter\u003c/h3\u003e\n\u003cp\u003eAdding \u003ccode\u003e^\u003c/code\u003e inside the brackets will cause the expression to look for all the character that does not match the characters inside the brackets\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eroot@User:~$ grep \"[^a-zA-Z0-9]\" day36.txt\r\n~\r\n.\r\n\\\r\n/\r\n(\r\n)\r\n-\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese are all the symbols that are written inside the text file.\u003c/p\u003e\n\u003ch3\u003eMatching Word Between Mentioned Numbers\u003c/h3\u003e\n\u003cp\u003eTo match words that are in the specifeid length in the text file I will use the following expression.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eroot@User:~$ grep \" [a-z]{5} \" day36.txt\r\nfifth\r\nother\r\nabout\r\nneeds\r\n...\r\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is like \"find all words of length five between a and z\"\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e{min, max}\u003c/code\u003e\u003c/strong\u003e Curly Brackets define the range of letter to look for\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e{5}\u003c/code\u003e\u003c/strong\u003e = five characters\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e{5, 9}\u003c/code\u003e\u003c/strong\u003e = five to nine characters\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e{5,}\u003c/code\u003e\u003c/strong\u003e = more than five characters\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e{,5}\u003c/code\u003e\u003c/strong\u003e = less or five characters\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd that's it for now because Regex can be much difficult to learn in one day, SO more of it tomorrow.\u003c/p\u003e\n","tags":["Linux"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-43"},"buildId":"0_eaq05hCOdrGJI-coTkt","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-08bb45713b568a3c61e0.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" async=""></script><script src="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-03337388e7702cb579d9.js" async=""></script><script src="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-124259c81ad6abc14284.js" async=""></script><script src="/blog/_next/static/0_eaq05hCOdrGJI-coTkt/_buildManifest.js" async=""></script><script src="/blog/_next/static/0_eaq05hCOdrGJI-coTkt/_ssgManifest.js" async=""></script></body></html>