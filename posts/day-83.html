<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preload" href="fonts.googleapis.com"/><title>Day 83 - Hardware Solution To Process Synchronization - zainsci-blog</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:title" content="zainsci-blog"/><meta property="og:description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:image" content="https://zainsci.github.io/potrait.jpg"/><meta property="og:url" content="https://zainsci.github.io/blog"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site_name" content="zainsci-blog"/><meta name="twitter:image:alt" content="zainsci&#x27;s portrait"/><meta name="next-head-count" content="13"/><link rel="preload" href="/blog/_next/static/css/7326876a07940d477f61.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/7326876a07940d477f61.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-707f2822c64b8f71e536.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-71e4839e0dfbb8f32ae2.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/996-df62062ac661a66a899d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-010c78845daa6a71ffcb.js" as="script"/></head><body><div id="__next"><header><h3 class="logo">zainsci-blog</h3><nav class="nav"><ul class="nav__list"><li class="nav__item"><a class="nav__link" href="/blog">Home</a></li><li class="nav__item"><a href="https://zainsci.github.io" class="nav__link" target="_blank" rel="noopener noreferrer">Portfolio</a></li><li class="nav__item"><a class="nav__link" href="/blog/blog/about">About</a></li><li class="nav__item"><a class="nav__link" href="/blog/blog/contact">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><a class="skip-link" href="#main">Skip to main</a><main id="main"><div class="share"><p>Share With Others</p><div class="share__buttons"><div class="share__button"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-83&amp;text=Day 83 - Hardware Solution To Process Synchronization
&amp;hashtags=zainsci,OperatingSystems" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></div><div class="share__button"><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-83" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div></div><article class="blog__post" itemscope="" itemType="http://schema.org/Article"><header><h1 itemProp="headline">Day 83 - Hardware Solution To Process Synchronization</h1><div itemProp="datePublished">2021-03-24</div></header><section itemProp="articleBody"><p>Last time we learned about the Critical Section problem and how we can hanlde it in operating systems. Today we will be learning about how we can solve the critical section problem at the hardware level. Critical Section Problem can be easily solved on the hardware-level and is much difficult on the software-level as we can have physical barriers to solve the problem.</p>
<p>The critical section problem can be solved in a single processor system at hardware level. We can stop interrupts to occur modification of shared variable so that the instruction can be executed without preemption. This solution is not applicable in multiprocessor system becasue disabling of interrupts is time consuming.</p>
<p>Many machines provide hardware instruction to test and modify a word and swap the contents of the words automatically without any interruption. The TestAndSet instruction is executed atomically.</p>
<p>The defination of TestAndSet is follows:</p>
<pre><code class="language-py">def TestAndSet(target):
    rv = target
    target = True
    return rv
</code></pre>
<p>A machine that supports TestAndSet instruction, can implement mutual exclusion by using a boolean variable lock, initialized as false. The structure of such implementation is as follows:</p>
<pre><code class="language-py">while True:
    while TestAndSet(lock):
        # Critical Section
    lock = False
    # Remainder Section
</code></pre>
<p>The Swap instruction is also executed atomically and operates on two words to interchange their contents.</p>
<pre><code class="language-py">def Swap(a, b):
    temp = a
    a = b
    b = temp
</code></pre>
<p>This way by using the boolean varibale we can halt the execution of more than one process that is using the same data.</p>
<h2>Memory Barriers</h2>
<p>There are two types of memory models that are implemented in computer architectures. <strong>Strongly</strong> and <strong>Waekly</strong> ordered.</p>
<ul>
<li><strong>Strongly ordered.</strong> In which the memory modification on one processor is immediately visible on all other processors.</li>
<li><strong>Weakly ordered.</strong> In which memory modification on one processor may not be immediatelt visible on all other processors.</li>
</ul>
<p>Memory models vary by different processors types so code written for one kernel may not work for some processors. To address this issue, computer architectures provide instructions that can <em>force</em> any change in memory to be propagated to all other processors in the system. These instructions are called <strong>Memory Barrirs</strong>.</p>
<p>When memory barrier instruction is performed, the system ensures that all loads and stores are completed before future loads and store operations are performed.</p>
</section></article><br/><br/><br/><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div><div class="social__icons undefined"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 83 - Hardware Solution To Process Synchronization","date":"2021-03-24","slug":"day-83","content":"\u003cp\u003eLast time we learned about the Critical Section problem and how we can hanlde it in operating systems. Today we will be learning about how we can solve the critical section problem at the hardware level. Critical Section Problem can be easily solved on the hardware-level and is much difficult on the software-level as we can have physical barriers to solve the problem.\u003c/p\u003e\n\u003cp\u003eThe critical section problem can be solved in a single processor system at hardware level. We can stop interrupts to occur modification of shared variable so that the instruction can be executed without preemption. This solution is not applicable in multiprocessor system becasue disabling of interrupts is time consuming.\u003c/p\u003e\n\u003cp\u003eMany machines provide hardware instruction to test and modify a word and swap the contents of the words automatically without any interruption. The TestAndSet instruction is executed atomically.\u003c/p\u003e\n\u003cp\u003eThe defination of TestAndSet is follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003edef TestAndSet(target):\r\n    rv = target\r\n    target = True\r\n    return rv\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA machine that supports TestAndSet instruction, can implement mutual exclusion by using a boolean variable lock, initialized as false. The structure of such implementation is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003ewhile True:\r\n    while TestAndSet(lock):\r\n        # Critical Section\r\n    lock = False\r\n    # Remainder Section\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Swap instruction is also executed atomically and operates on two words to interchange their contents.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003edef Swap(a, b):\r\n    temp = a\r\n    a = b\r\n    b = temp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis way by using the boolean varibale we can halt the execution of more than one process that is using the same data.\u003c/p\u003e\n\u003ch2\u003eMemory Barriers\u003c/h2\u003e\n\u003cp\u003eThere are two types of memory models that are implemented in computer architectures. \u003cstrong\u003eStrongly\u003c/strong\u003e and \u003cstrong\u003eWaekly\u003c/strong\u003e ordered.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStrongly ordered.\u003c/strong\u003e In which the memory modification on one processor is immediately visible on all other processors.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWeakly ordered.\u003c/strong\u003e In which memory modification on one processor may not be immediatelt visible on all other processors.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMemory models vary by different processors types so code written for one kernel may not work for some processors. To address this issue, computer architectures provide instructions that can \u003cem\u003eforce\u003c/em\u003e any change in memory to be propagated to all other processors in the system. These instructions are called \u003cstrong\u003eMemory Barrirs\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen memory barrier instruction is performed, the system ensures that all loads and stores are completed before future loads and store operations are performed.\u003c/p\u003e\n","tags":["Operating-Systems"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-83"},"buildId":"qZVnrEIsLwc-3W0IP4yUl","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-707f2822c64b8f71e536.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" async=""></script><script src="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-71e4839e0dfbb8f32ae2.js" async=""></script><script src="/blog/_next/static/chunks/996-df62062ac661a66a899d.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-010c78845daa6a71ffcb.js" async=""></script><script src="/blog/_next/static/qZVnrEIsLwc-3W0IP4yUl/_buildManifest.js" async=""></script><script src="/blog/_next/static/qZVnrEIsLwc-3W0IP4yUl/_ssgManifest.js" async=""></script></body></html>