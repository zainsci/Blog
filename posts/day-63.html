<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preload" href="fonts.googleapis.com"/><title>Day 63 - Scheduling and Scheduling Algorithms [0] - zainsci-blog</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:title" content="zainsci-blog"/><meta property="og:description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:image" content="https://zainsci.github.io/potrait.jpg"/><meta property="og:url" content="https://zainsci.github.io/blog"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site_name" content="zainsci-blog"/><meta name="twitter:image:alt" content="zainsci&#x27;s portrait"/><meta name="next-head-count" content="13"/><link rel="preload" href="/blog/_next/static/css/0c96731d08ff48ae1e8e.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/0c96731d08ff48ae1e8e.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-84092be9fe5c9e92d400.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-cf1093b9ea91d73058f6.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-1542e9ee45162339ba8f.js" as="script"/></head><body><div id="__next"><header class="header"><div><h3 class="logo">zainsci-blog</h3><div class="nav__toggler"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div></div><nav class="nav"><ul class="nav__list"><li class="nav__item"><a class="nav__link" href="/blog">Home</a></li><li class="nav__item"><a href="https://zainsci.github.io" class="nav__link" target="_blank" rel="noopener noreferrer">Portfolio</a></li><li class="nav__item"><a class="nav__link" href="/blog/about">About</a></li><li class="nav__item"><a class="nav__link" href="/blog/contact">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><a class="skip-link" href="#main">Skip to main</a><main id="main"><article class="article" itemscope="" itemType="http://schema.org/Article"><div class="share"><p>Share</p><div class="share__buttons"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-63&amp;text=Day 63 - Scheduling and Scheduling Algorithms [0]
&amp;hashtags=zainsci,DataStructures,Algorithms" target="_blank" rel="noreferrer" class="share__button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-63" target="_blank" rel="noreferrer" class="share__button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div><header class="article__header"><h1 itemProp="headline">Day 63 - Scheduling and Scheduling Algorithms [0]</h1><div itemProp="datePublished">2021-03-04</div></header><section itemProp="articleBody" class="article__body"><p>Last day I learned about some simple algorihtms that are used in the OS design and today I will be learning about more algorithms that are also used in Operating Systems. These are scheduling algorithms that are mostly used in the Operating System's Scheduler for scheduling tasks.</p>
<h2>Process Scheduler</h2>
<p>A Process Scheduler is a part of the operating system that makes the decision for the CPU on what porcess to select form the queue to perform actions on it. The processes are placed in a queue and are selected by the scheduler to take actions on them by the CPU. There are three types of schedulers that work in an operating system but I will not be going in depth about them because this is about algorithms only and these are:</p>
<ul>
<li>Long Term Scheduler</li>
<li>Short Term Scheduler</li>
<li>Medium Term Scheduler</li>
</ul>
<h2>Scheduling Algorithms</h2>
<p>A scheduler uses algorithms to decide the prioirty of the processes in the queue to feed them to the CPU and these algorithms are called Scheduler algorithms. There are atleast six very commin kinds of scheduler algorithms and I will be doning two of them today and maybe three or four of them tomorrow.</p>
<ul>
<li>FCFS Scheduling</li>
<li>SJF Scheduling</li>
<li>Priority Scheduling</li>
<li>Round Robin Scheduling</li>
<li>MLQ Scheduling</li>
<li>Multiple Processor Scheduling</li>
</ul>
<h3>First Come First Serve (FCFS) Scheduling</h3>
<p>A scheduling algorithm which is based on First Come First Serve basis. It means the process that enters the queue first will be executed first and so on. It is easy to implement and understand and kind of works the same way as the Data Structure Queue.</p>
<p>The disadvantages of this algorithm is that it is very much slow than most of the algorithms in the list. and takes a lot of time to process.</p>
<pre><code class="language-js">----- Before Execution -----

----- Processes -----
|1|2|3|4|5|6|7|8|9|

processBeingExecuted = 0
nextProcess = 1


----- After Execution -----

----- Processes -----
|2|3|4|5|6|7|8|9|

processBeingExecuted = 1
nextProcess = 2

</code></pre>
<h3>Shortest Job First (SJF) Scheduling</h3>
<p>Shortest Job First Scheduling algorithm pick the process first that will take the least amount of time to complete. By this way average waiting time is reduced by running the shortest job first. And easy to implement in systems where CPU time id known in advance and impossible to implement in systems where the process time is unknow at first. That is why to make is work fast, process time should be know at the beginnig of the process.</p>
<pre><code class="language-js">
|  Job  |  Arrival Time  |  Process Time  |
|   0   |  1             |  5             |
|   1   |  0             |  2             |
|   2   |  2             |  1             |

processQueue = [2, 1, 0] // Based on Process Time

</code></pre>
</section></article><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div><div class="social__icons undefined"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 63 - Scheduling and Scheduling Algorithms [0]","date":"2021-03-04","slug":"day-63","content":"\u003cp\u003eLast day I learned about some simple algorihtms that are used in the OS design and today I will be learning about more algorithms that are also used in Operating Systems. These are scheduling algorithms that are mostly used in the Operating System's Scheduler for scheduling tasks.\u003c/p\u003e\n\u003ch2\u003eProcess Scheduler\u003c/h2\u003e\n\u003cp\u003eA Process Scheduler is a part of the operating system that makes the decision for the CPU on what porcess to select form the queue to perform actions on it. The processes are placed in a queue and are selected by the scheduler to take actions on them by the CPU. There are three types of schedulers that work in an operating system but I will not be going in depth about them because this is about algorithms only and these are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLong Term Scheduler\u003c/li\u003e\n\u003cli\u003eShort Term Scheduler\u003c/li\u003e\n\u003cli\u003eMedium Term Scheduler\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eScheduling Algorithms\u003c/h2\u003e\n\u003cp\u003eA scheduler uses algorithms to decide the prioirty of the processes in the queue to feed them to the CPU and these algorithms are called Scheduler algorithms. There are atleast six very commin kinds of scheduler algorithms and I will be doning two of them today and maybe three or four of them tomorrow.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFCFS Scheduling\u003c/li\u003e\n\u003cli\u003eSJF Scheduling\u003c/li\u003e\n\u003cli\u003ePriority Scheduling\u003c/li\u003e\n\u003cli\u003eRound Robin Scheduling\u003c/li\u003e\n\u003cli\u003eMLQ Scheduling\u003c/li\u003e\n\u003cli\u003eMultiple Processor Scheduling\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eFirst Come First Serve (FCFS) Scheduling\u003c/h3\u003e\n\u003cp\u003eA scheduling algorithm which is based on First Come First Serve basis. It means the process that enters the queue first will be executed first and so on. It is easy to implement and understand and kind of works the same way as the Data Structure Queue.\u003c/p\u003e\n\u003cp\u003eThe disadvantages of this algorithm is that it is very much slow than most of the algorithms in the list. and takes a lot of time to process.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e----- Before Execution -----\r\n\r\n----- Processes -----\r\n|1|2|3|4|5|6|7|8|9|\r\n\r\nprocessBeingExecuted = 0\r\nnextProcess = 1\r\n\r\n\r\n----- After Execution -----\r\n\r\n----- Processes -----\r\n|2|3|4|5|6|7|8|9|\r\n\r\nprocessBeingExecuted = 1\r\nnextProcess = 2\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eShortest Job First (SJF) Scheduling\u003c/h3\u003e\n\u003cp\u003eShortest Job First Scheduling algorithm pick the process first that will take the least amount of time to complete. By this way average waiting time is reduced by running the shortest job first. And easy to implement in systems where CPU time id known in advance and impossible to implement in systems where the process time is unknow at first. That is why to make is work fast, process time should be know at the beginnig of the process.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\r\n|  Job  |  Arrival Time  |  Process Time  |\r\n|   0   |  1             |  5             |\r\n|   1   |  0             |  2             |\r\n|   2   |  2             |  1             |\r\n\r\nprocessQueue = [2, 1, 0] // Based on Process Time\r\n\n\u003c/code\u003e\u003c/pre\u003e\n","tags":["Data-Structures","Algorithms"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-63"},"buildId":"OPvkZP5UcKfJr3zVYO5EN","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-84092be9fe5c9e92d400.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" async=""></script><script src="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-cf1093b9ea91d73058f6.js" async=""></script><script src="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-1542e9ee45162339ba8f.js" async=""></script><script src="/blog/_next/static/OPvkZP5UcKfJr3zVYO5EN/_buildManifest.js" async=""></script><script src="/blog/_next/static/OPvkZP5UcKfJr3zVYO5EN/_ssgManifest.js" async=""></script></body></html>