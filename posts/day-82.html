<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preload" href="fonts.googleapis.com"/><title>Day 82 - The Critical Section Problem - zainsci-blog</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:title" content="zainsci-blog"/><meta property="og:description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:image" content="https://zainsci.github.io/potrait.jpg"/><meta property="og:url" content="https://zainsci.github.io/blog"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site_name" content="zainsci-blog"/><meta name="twitter:image:alt" content="zainsci&#x27;s portrait"/><meta name="next-head-count" content="13"/><link rel="preload" href="/blog/_next/static/css/7326876a07940d477f61.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/7326876a07940d477f61.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-cddfcfdf8da773bbd1c2.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-71e4839e0dfbb8f32ae2.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/996-df62062ac661a66a899d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-65a5e5c9d01616dc97fe.js" as="script"/></head><body><div id="__next"><header><h3 class="logo">zainsci-blog</h3><nav class="nav"><ul class="nav__list"><li class="nav__item"><a class="nav__link" href="/blog">Home</a></li><li class="nav__item"><a href="https://zainsci.github.io" class="nav__link" target="_blank" rel="noopener noreferrer">Portfolio</a></li><li class="nav__item"><a class="nav__link" href="/blog/about">About</a></li><li class="nav__item"><a class="nav__link" href="/blog/contact">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><a class="skip-link" href="#main">Skip to main</a><main id="main"><div class="share"><p>Share With Others</p><div class="share__buttons"><div class="share__button"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-82&amp;text=Day 82 - The Critical Section Problem
&amp;hashtags=zainsci,OperatingSystems" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></div><div class="share__button"><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-82" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div></div><article class="blog__post" itemscope="" itemType="http://schema.org/Article"><header><h1 itemProp="headline">Day 82 - The Critical Section Problem</h1><div itemProp="datePublished">2021-03-23</div></header><section itemProp="articleBody"><p>Last time we learned about the Process Synchronization and Race Condition where in race condition a two processes running at the same time and accessing the same variable can result in unwanted results which can hinder the ability of other processes to work properly in the future.</p>
<p>Today we will be discussing about the <strong>Critical Section Problem</strong> in process synchronization. This problem is discussed in order to prevent race conditions from occuring. Critical section problem states that no two processes should access the same varibale or data at the same time.</p>
<p>Consider a system where there are <strong>n</strong> number of processes running at the same time. Each process has a segment of code called critical section in which they share, access or manipulate data. The important thing here is that when one process is executing in this critical condition no other process should be allowed to execute in critical condition.</p>
<p>The critical section problem is to design a protocol to let all the processes synchronize their execution in order to share data cooperatively. Each process must ask for permission to enter the critical section. The section of code that is using the shared data is called the <strong>entry section</strong> and after entry section is done executing the process enters <strong>exit section</strong>. The remainder of code is called <strong>remainder section</strong>.</p>
<p>A solution to the <strong>Critical-Section Problem</strong> must satisfy the following three requirements.</p>
<ul>
<li><strong>Mutual exclusion.</strong> If a process P1 is executing in the critical section, then no other process can be executing in the critical sections.</li>
<li><strong>Progress.</strong> If no process is executing in its critical section then some process that is not executing in their remainder section can ask for entering the critical section. The selection cannot be postponed indefinately.</li>
<li><strong>Bounded Waiting.</strong> There is a limit on the number of times that other processes are allowed to enter their critical section after a process has made a request to enter the critical section and that process is granted the access to the critical section.</li>
</ul>
<p>Following are two approaches that are used to handle the critical section of processes in the operating systems.</p>
<h3>Preemptive Kernels</h3>
<p>Preempted kernel allows a process to be preempted while it is running in the kernel mode. In preemptive kernels race conditions must be handeled by properly implementing the kernels so that the only one process can enter the critical section at the same time.</p>
<h3>Non-Preemptive Kernels</h3>
<p>Non-Preempted kernel does not allows a process to be preempted running in the kernel mode. a kernel-mode process will run unitl it exits kernle mode or blocks or voluntarily yields control of the CPU.</p>
<p>A nonpreemptive kernel is free of race conditiions as only one process runs in the kernel at a time.</p>
</section></article><br/><br/><br/><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div><div class="social__icons undefined"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 82 - The Critical Section Problem","date":"2021-03-23","slug":"day-82","content":"\u003cp\u003eLast time we learned about the Process Synchronization and Race Condition where in race condition a two processes running at the same time and accessing the same variable can result in unwanted results which can hinder the ability of other processes to work properly in the future.\u003c/p\u003e\n\u003cp\u003eToday we will be discussing about the \u003cstrong\u003eCritical Section Problem\u003c/strong\u003e in process synchronization. This problem is discussed in order to prevent race conditions from occuring. Critical section problem states that no two processes should access the same varibale or data at the same time.\u003c/p\u003e\n\u003cp\u003eConsider a system where there are \u003cstrong\u003en\u003c/strong\u003e number of processes running at the same time. Each process has a segment of code called critical section in which they share, access or manipulate data. The important thing here is that when one process is executing in this critical condition no other process should be allowed to execute in critical condition.\u003c/p\u003e\n\u003cp\u003eThe critical section problem is to design a protocol to let all the processes synchronize their execution in order to share data cooperatively. Each process must ask for permission to enter the critical section. The section of code that is using the shared data is called the \u003cstrong\u003eentry section\u003c/strong\u003e and after entry section is done executing the process enters \u003cstrong\u003eexit section\u003c/strong\u003e. The remainder of code is called \u003cstrong\u003eremainder section\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA solution to the \u003cstrong\u003eCritical-Section Problem\u003c/strong\u003e must satisfy the following three requirements.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMutual exclusion.\u003c/strong\u003e If a process P1 is executing in the critical section, then no other process can be executing in the critical sections.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProgress.\u003c/strong\u003e If no process is executing in its critical section then some process that is not executing in their remainder section can ask for entering the critical section. The selection cannot be postponed indefinately.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBounded Waiting.\u003c/strong\u003e There is a limit on the number of times that other processes are allowed to enter their critical section after a process has made a request to enter the critical section and that process is granted the access to the critical section.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFollowing are two approaches that are used to handle the critical section of processes in the operating systems.\u003c/p\u003e\n\u003ch3\u003ePreemptive Kernels\u003c/h3\u003e\n\u003cp\u003ePreempted kernel allows a process to be preempted while it is running in the kernel mode. In preemptive kernels race conditions must be handeled by properly implementing the kernels so that the only one process can enter the critical section at the same time.\u003c/p\u003e\n\u003ch3\u003eNon-Preemptive Kernels\u003c/h3\u003e\n\u003cp\u003eNon-Preempted kernel does not allows a process to be preempted running in the kernel mode. a kernel-mode process will run unitl it exits kernle mode or blocks or voluntarily yields control of the CPU.\u003c/p\u003e\n\u003cp\u003eA nonpreemptive kernel is free of race conditiions as only one process runs in the kernel at a time.\u003c/p\u003e\n","tags":["Operating-Systems"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-82"},"buildId":"GFEYPi5ZvbnQiD2zpSf_A","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-cddfcfdf8da773bbd1c2.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" async=""></script><script src="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-71e4839e0dfbb8f32ae2.js" async=""></script><script src="/blog/_next/static/chunks/996-df62062ac661a66a899d.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-65a5e5c9d01616dc97fe.js" async=""></script><script src="/blog/_next/static/GFEYPi5ZvbnQiD2zpSf_A/_buildManifest.js" async=""></script><script src="/blog/_next/static/GFEYPi5ZvbnQiD2zpSf_A/_ssgManifest.js" async=""></script></body></html>