<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preload" href="fonts.googleapis.com"/><title>Day 100 - Loading And Linking - zainsci-blog</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:title" content="zainsci-blog"/><meta property="og:description" content="A place for me, zainsci, to share what I learn about computers and programming."/><meta property="og:image" content="https://zainsci.github.io/potrait.jpg"/><meta property="og:url" content="https://zainsci.github.io/blog"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site_name" content="zainsci-blog"/><meta name="twitter:image:alt" content="zainsci&#x27;s portrait"/><meta name="next-head-count" content="13"/><link rel="preload" href="/blog/_next/static/css/f5020a7d73287f004ca3.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f5020a7d73287f004ca3.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-99548df9de19475cfb6c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-117f6fafc0903339435d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-4fb861a235fdc57dda1f.js" as="script"/></head><body><div id="__next"><header><h3 class="logo">zainsci-blog</h3><nav class="nav"><ul class="nav__list"><li class="nav__item"><a class="nav__link" href="/blog">Home</a></li><li class="nav__item"><a href="https://zainsci.github.io" class="nav__link" target="_blank" rel="noopener noreferrer">Portfolio</a></li><li class="nav__item"><a class="nav__link" href="/blog/about">About</a></li><li class="nav__item"><a class="nav__link" href="/blog/contact">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><a class="skip-link" href="#main">Skip to main</a><main id="main"><div class="share"><p>Share With Others</p><div class="share__buttons"><div class="share__button"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-100&amp;text=Day 100 - Loading And Linking
&amp;hashtags=zainsci,OperatingSystems" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></div><div class="share__button"><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-100" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div></div><article class="blog__post" itemscope="" itemType="http://schema.org/Article"><header><h1 itemProp="headline">Day 100 - Loading And Linking</h1><div itemProp="datePublished">2021-04-10</div></header><section itemProp="articleBody"><p>Now we know how a program is translated and binded from logical address to physical addresses in the main memroy. Today's topic is going to be how a program is loaded and linked for exection.</p>
<p>Following are the ways by which the program loading is performed.</p>
<h3>Absolute Loading</h3>
<p>An absolute loader loads the load-module into the memory as it is. It makes no changes to the logical addresses assigend by the translator and assumes that the translator or the programmer has already assigned the correct addresses. With this approcah the load module must always occupy the same space in the main memory as it does in the disk storage. This approach to loading is never used.</p>
<h3>Re-Locatable Loading</h3>
<p>In Re-Locateable Loading, the loader adds an ofset to all the logical addresses while copying the module in the main memory. This type of loader wants the translator the generate relative addresses. It is also necessary for the program to be loaded into the consecutive memroy and the physical addresses are found by adding <strong>M</strong> in front to each relative address.</p>
<p>In this case the addresses are bound at run time rather than at build time. It is a more flexible approach the complie time binding. The program can be loaded into separate set of locations everytime it runs. Re-Locateable Loading provides more multiprogramming than absolute loading. In absolute loading the programs that have the same address cannot run at the same time while re-locatable loading does not have this problem which makes it easier for programmers because they don't have to tell where to store every instruction.</p>
<h3>Dynamic Loading (Dynamic Relocation)</h3>
<p>Re-locatable loading does not support swapping which means that once a process is swapped out from the memory it cannot be reloaded into the memory and have the same addresses as it had previously. Once a process is loaded and relocated in the memory it becomes absolute.</p>
<p>Dynamic Loading defers the process of determining absolute addresses until the address is used. The loader places the the load module into the memroy without adjusting relative addresses. A special register is loaded with the start address of the module. Hardware automatically adds the register contents to a relative address each time the address is used. In this case, address binding is at runtime and relocation is done each time the address is used.</p>
<h3>Linking</h3>
<p>A linker joins many modules to form a single load module. Linker takes load modules as input. Each module is translated with relative addresses, relative to 0 as the start address of the module. References to other modules such as function and variables are still symbolic. A linker must create a single module in which all the external references are resolved. The term <strong>Linkage Editor</strong> is applied to this type of linker.</p>
<p>The Linker postpones some of the linkage functions until the run time. Dunamic linking can be done at load time or at run time. Load-time dynamic linking creates a relocateable module in a normal way. It leaves some external references unresolved. There references are usually to the system utilites or language libraries. The system copies of the linked modules can be linked at the load time. The utilites can be changed without forcing the programmers to re-link existing modules. A shared code can be linked to more than one program. Run-time dynamic linking goes a step futhur. Some modules are not linked in until they are actually called.</p>
</section></article><br/><br/><br/><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div><div class="social__icons undefined"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 100 - Loading And Linking","date":"2021-04-10","slug":"day-100","content":"\u003cp\u003eNow we know how a program is translated and binded from logical address to physical addresses in the main memroy. Today's topic is going to be how a program is loaded and linked for exection.\u003c/p\u003e\n\u003cp\u003eFollowing are the ways by which the program loading is performed.\u003c/p\u003e\n\u003ch3\u003eAbsolute Loading\u003c/h3\u003e\n\u003cp\u003eAn absolute loader loads the load-module into the memory as it is. It makes no changes to the logical addresses assigend by the translator and assumes that the translator or the programmer has already assigned the correct addresses. With this approcah the load module must always occupy the same space in the main memory as it does in the disk storage. This approach to loading is never used.\u003c/p\u003e\n\u003ch3\u003eRe-Locatable Loading\u003c/h3\u003e\n\u003cp\u003eIn Re-Locateable Loading, the loader adds an ofset to all the logical addresses while copying the module in the main memory. This type of loader wants the translator the generate relative addresses. It is also necessary for the program to be loaded into the consecutive memroy and the physical addresses are found by adding \u003cstrong\u003eM\u003c/strong\u003e in front to each relative address.\u003c/p\u003e\n\u003cp\u003eIn this case the addresses are bound at run time rather than at build time. It is a more flexible approach the complie time binding. The program can be loaded into separate set of locations everytime it runs. Re-Locateable Loading provides more multiprogramming than absolute loading. In absolute loading the programs that have the same address cannot run at the same time while re-locatable loading does not have this problem which makes it easier for programmers because they don't have to tell where to store every instruction.\u003c/p\u003e\n\u003ch3\u003eDynamic Loading (Dynamic Relocation)\u003c/h3\u003e\n\u003cp\u003eRe-locatable loading does not support swapping which means that once a process is swapped out from the memory it cannot be reloaded into the memory and have the same addresses as it had previously. Once a process is loaded and relocated in the memory it becomes absolute.\u003c/p\u003e\n\u003cp\u003eDynamic Loading defers the process of determining absolute addresses until the address is used. The loader places the the load module into the memroy without adjusting relative addresses. A special register is loaded with the start address of the module. Hardware automatically adds the register contents to a relative address each time the address is used. In this case, address binding is at runtime and relocation is done each time the address is used.\u003c/p\u003e\n\u003ch3\u003eLinking\u003c/h3\u003e\n\u003cp\u003eA linker joins many modules to form a single load module. Linker takes load modules as input. Each module is translated with relative addresses, relative to 0 as the start address of the module. References to other modules such as function and variables are still symbolic. A linker must create a single module in which all the external references are resolved. The term \u003cstrong\u003eLinkage Editor\u003c/strong\u003e is applied to this type of linker.\u003c/p\u003e\n\u003cp\u003eThe Linker postpones some of the linkage functions until the run time. Dunamic linking can be done at load time or at run time. Load-time dynamic linking creates a relocateable module in a normal way. It leaves some external references unresolved. There references are usually to the system utilites or language libraries. The system copies of the linked modules can be linked at the load time. The utilites can be changed without forcing the programmers to re-link existing modules. A shared code can be linked to more than one program. Run-time dynamic linking goes a step futhur. Some modules are not linked in until they are actually called.\u003c/p\u003e\n","tags":["Operating-Systems"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-100"},"buildId":"X1-XAhxg-nNUzaHZmPDCi","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-99548df9de19475cfb6c.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/commons-0392153403293a8cddd0.js" async=""></script><script src="/blog/_next/static/chunks/main-06aae30c278b6ca2f76a.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-117f6fafc0903339435d.js" async=""></script><script src="/blog/_next/static/chunks/296-8ee5d6e875fb38ba58c0.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-4fb861a235fdc57dda1f.js" async=""></script><script src="/blog/_next/static/X1-XAhxg-nNUzaHZmPDCi/_buildManifest.js" async=""></script><script src="/blog/_next/static/X1-XAhxg-nNUzaHZmPDCi/_ssgManifest.js" async=""></script></body></html>