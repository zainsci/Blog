<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Day 80 - How Linux Schedules Its Processes - zainsci-blog</title><meta name="next-head-count" content="3"/><link rel="preload" href="/blog/_next/static/css/7326876a07940d477f61.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/7326876a07940d477f61.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-68b33a983b217570410c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/597-b00db1c133ea663e36f8.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/778-0eca3c12d3dbfbf41974.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-d0383bb574e856e8c82c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/885-1a3ba520d6a771969c4b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-38ecf2de6125847544d2.js" as="script"/></head><body><div id="__next"><header><h3 class="logo">zainsci-blog</h3><nav class="nav"><ul class="nav__list"><li class="nav__item"><a href="/" class="nav__link">Home</a></li><li class="nav__item"><a href="/portfolio" class="nav__link">Portfolio</a></li><li class="nav__item"><a href="/about" class="nav__link">About</a></li><li class="nav__item"><a href="/contact" class="nav__link">Contact</a></li><li class="nav__item"><div class="toggler"><a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></a></div></li></ul></nav></header><main><div class="share"><p>Share With Others</p><div class="share__buttons"><div class="share__button"><a href="https://twitter.com/intent/tweet?url=https://zainsci.github.ioday-80&amp;text=Day 80 - How Linux Schedules Its Processes
&amp;hashtags=zainsci,OperatingSystems" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></div><div class="share__button"><a href="https://www.facebook.com/sharer/sharer.php?u=zainsci.github.io%2Fblogday-80" target="_blank" rel="noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a></div></div></div><article class="blog__post" itemscope="" itemType="http://schema.org/Article"><header><h1 itemProp="headline">Day 80 - How Linux Schedules Its Processes</h1><div itemProp="datePublished">2021-03-21</div></header><section itemProp="articleBody"><p>So far we have learned about the CPU scheduling, Objectives and Working of a Scheduler and Multi-Processor Scheduling and there are many things we haven't learned about scheduling which were overwhelming for me so for now I left them and the reason why I didn't wrote about the scheduling algorithms was because I already did wrote about them in the earlier posts in the Algorithms Series in <a href="/day-63/">Day 63</a> and <a href="/day-64/">Day 64</a>. But now we will be looking at some examples of scheduling in Operating Systems mainly in Linux and Windows. Vur for today we will be only learnig about the Linux Scheduling.</p>
<h2>Scheduling In Linux</h2>
<p>In the earlier versions of the Linux Kernel, the scheduler was not designed with SMP (Symmetric Multi-Processing) systems in mind so it didn't worked properly with the systems with a large number of processors running at the same time. So programmers at Linux worked for some time and came up with the scheduling algorithm which later became the default Linux scheduling algorithm. It is called Completely Fair Scheduler or CFS for short.</p>
<p>Linux schedules processes in terms of scheduling classes and each class is assigned to a specific priority. To select which process to run next the scheduler will select the highest-priority task from the highest-priority class. Standard Linux kernel implements two scheduling classes.</p>
<ul>
<li>with CFS scheduling algorithm</li>
<li>with real-time scheduling class</li>
</ul>
<p>Other classes can also be added to it.</p>
<p>The CFS scheduling algorithm assigns the CPU for a proportion of processing time to all the tasks. This proportion of processing time is calculated based on the <strong>nice value</strong> that is between +19 to -20 where lower value indicates higher priority. The default nice value for each task is 0 and lower the nice value, higher the time it will get to be processed by the CPU. (The term nice comes from the idea that if a task increases its nice value from, say, 0 to +10, it is being nice to other tasks in the system by lowering its relative priority. In other words, nice processes finish last!).</p>
<p>Linux does not have a default value of time for which a task should run but a <strong>targeted latency</strong>, which is the interval of time a process should run at least once. Proportions of processing time are allocated from the value of <strong>targeted latency</strong>. Targeted latency can be increased if the number of active tasks increase from a certain threshold.</p>
<p>CFS assigns the priorities to the tasks by recording how long a task have been running up until now by maintaining the <strong>virtual run time</strong> of each task. it will select the task with the minimum virtual run time and higher priority to be assigned to the CPU for processing. For this it uses a variable <strong>vruntime</strong>. The virtual run time of each task is associated with the decay factor of each task. The decay factor of a task with lower priority will be higher than that of the task with high priority.</p>
<p>This is motly how Linux Process Scheduler works. I have missed many things in this but this much is enough for now. These topics are becoming more complex to grasp than imagened before so we will see what will hapeen next.</p>
</section></article><br/><br/><br/><hr/></main><footer class="footer"><div>Copyright Â© <!-- -->2021<!-- --> zainsci</div><div>Built with Next.js by<!-- --> <a href="https://zainsci.github.io" target="_blank" rel="noopener noreferrer">zainsci</a></div><div><div><div class="social__icons undefined"><a href="https://twitter.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://instagram.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg></a><a href="https://github.com/zainsci" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Day 80 - How Linux Schedules Its Processes","date":"2021-03-21","slug":"day-80","content":"\u003cp\u003eSo far we have learned about the CPU scheduling, Objectives and Working of a Scheduler and Multi-Processor Scheduling and there are many things we haven't learned about scheduling which were overwhelming for me so for now I left them and the reason why I didn't wrote about the scheduling algorithms was because I already did wrote about them in the earlier posts in the Algorithms Series in \u003ca href=\"/day-63/\"\u003eDay 63\u003c/a\u003e and \u003ca href=\"/day-64/\"\u003eDay 64\u003c/a\u003e. But now we will be looking at some examples of scheduling in Operating Systems mainly in Linux and Windows. Vur for today we will be only learnig about the Linux Scheduling.\u003c/p\u003e\n\u003ch2\u003eScheduling In Linux\u003c/h2\u003e\n\u003cp\u003eIn the earlier versions of the Linux Kernel, the scheduler was not designed with SMP (Symmetric Multi-Processing) systems in mind so it didn't worked properly with the systems with a large number of processors running at the same time. So programmers at Linux worked for some time and came up with the scheduling algorithm which later became the default Linux scheduling algorithm. It is called Completely Fair Scheduler or CFS for short.\u003c/p\u003e\n\u003cp\u003eLinux schedules processes in terms of scheduling classes and each class is assigned to a specific priority. To select which process to run next the scheduler will select the highest-priority task from the highest-priority class. Standard Linux kernel implements two scheduling classes.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewith CFS scheduling algorithm\u003c/li\u003e\n\u003cli\u003ewith real-time scheduling class\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOther classes can also be added to it.\u003c/p\u003e\n\u003cp\u003eThe CFS scheduling algorithm assigns the CPU for a proportion of processing time to all the tasks. This proportion of processing time is calculated based on the \u003cstrong\u003enice value\u003c/strong\u003e that is between +19 to -20 where lower value indicates higher priority. The default nice value for each task is 0 and lower the nice value, higher the time it will get to be processed by the CPU. (The term nice comes from the idea that if a task increases its nice value from, say, 0 to +10, it is being nice to other tasks in the system by lowering its relative priority. In other words, nice processes finish last!).\u003c/p\u003e\n\u003cp\u003eLinux does not have a default value of time for which a task should run but a \u003cstrong\u003etargeted latency\u003c/strong\u003e, which is the interval of time a process should run at least once. Proportions of processing time are allocated from the value of \u003cstrong\u003etargeted latency\u003c/strong\u003e. Targeted latency can be increased if the number of active tasks increase from a certain threshold.\u003c/p\u003e\n\u003cp\u003eCFS assigns the priorities to the tasks by recording how long a task have been running up until now by maintaining the \u003cstrong\u003evirtual run time\u003c/strong\u003e of each task. it will select the task with the minimum virtual run time and higher priority to be assigned to the CPU for processing. For this it uses a variable \u003cstrong\u003evruntime\u003c/strong\u003e. The virtual run time of each task is associated with the decay factor of each task. The decay factor of a task with lower priority will be higher than that of the task with high priority.\u003c/p\u003e\n\u003cp\u003eThis is motly how Linux Process Scheduler works. I have missed many things in this but this much is enough for now. These topics are becoming more complex to grasp than imagened before so we will see what will hapeen next.\u003c/p\u003e\n","tags":["Operating-Systems"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"day-80"},"buildId":"Fy0YqD2NVJUYLq0OzYr_B","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-68b33a983b217570410c.js" async=""></script><script src="/blog/_next/static/chunks/framework-9bf9f61c21c28db23d5b.js" async=""></script><script src="/blog/_next/static/chunks/597-b00db1c133ea663e36f8.js" async=""></script><script src="/blog/_next/static/chunks/778-0eca3c12d3dbfbf41974.js" async=""></script><script src="/blog/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-d0383bb574e856e8c82c.js" async=""></script><script src="/blog/_next/static/chunks/885-1a3ba520d6a771969c4b.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-38ecf2de6125847544d2.js" async=""></script><script src="/blog/_next/static/Fy0YqD2NVJUYLq0OzYr_B/_buildManifest.js" async=""></script><script src="/blog/_next/static/Fy0YqD2NVJUYLq0OzYr_B/_ssgManifest.js" async=""></script></body></html>