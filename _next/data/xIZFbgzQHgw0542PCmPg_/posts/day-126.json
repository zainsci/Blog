{"pageProps":{"post":{"title":"Day 126 - Generics In Rust","date":"2021-05-06","slug":"day-126","content":"<p>Last time we learned about HashMaps and how we create and insert values into a HashMap etc and now we will be looking at Generics. So What are Generics?</p>\n<h2>Generics</h2>\n<p>Geneerics allow us to reduce duplicated code. But that is not all it does. It makes our code more felxible and lets us use whatever type we want for a single function, struct or enums etc. But what does this all mean. Let me explain.</p>\n<p>Consider we have a function that adds two numbers. it takes two number as argument and returns a number that is the sum of those two numbers. Both of these numbers we provide are of type <code>i32</code> and will return type <code>i32</code> integer.</p>\n<pre><code class=\"language-rs\">fn add(x: i32, y: i32) -> i32 {\r\n    x + y\r\n}\n</code></pre>\n<p>But now we want to add two floating point numbers and we cannot do that with out current function because it only accepts integers of type <code>i32</code> and will return <code>i32</code>. So to do that we can write another function that takes float types and return floating type intergers.</p>\n<pre><code class=\"language-rs\">fn add(x: f32, y: f32) {\r\n    x + y\r\n}\n</code></pre>\n<p>First problem with this thing is that we have to add some kind of identification for both function to tell that what function to use at what point. By this i mean that we cannot name both functions the same so we have to name them like <code>f_add</code> and <code>i_add</code> and so.</p>\n<p>Second problem with this is that it will create so much duplicate code for all the things that we want to do but to do that we have to rewite the code.</p>\n<p>To solution to this and many more problems is called Generics.</p>\n<h3>Using Generics</h3>\n<p>Generics are like placeholder types that we use to define a function, enum or struct that we can later reuse with the type of out choice. This means that we only have to write the function add for once and we can use the add function which can return both floats and ints as we want.</p>\n<p>To write functions with Generics we use angle brackets after the name of the function and inside those brackets we use a placeholder name and inplace of the return type we use the same plceholder.</p>\n<pre><code class=\"language-rs\">fn add&#x3C;T>(x: T, y: T) -> T {\r\n    x + y\r\n}\n</code></pre>\n<p>Now if we provide the function with <code>i32</code> it will replace the <code>T</code> with <code>i32</code> and if we use the <code>f32</code> it will replace the <code>T</code> with <code>f32</code> and so on.</p>\n<pre><code class=\"language-rs\">add(1, 3); // 4 of type i32\r\nadd(1.1, 3.3); // 4.4 of type f32\n</code></pre>\n<h3>In Structs</h3>\n<p>To use Generics in Struct we use the same syntax as in functions.</p>\n<pre><code class=\"language-rs\">struct Point&#x3C;T> {\r\n    x: T,\r\n    y: T,\r\n}\r\n\r\nfn main() {\r\n    let ints = Point {x: 10, y: 12};\r\n    let floats = Point {x: 10.5, y: 12.5};\r\n}\n</code></pre>\n<p>Also we can use multiple types in the structs by using more than one types in the angle brackets.</p>\n<pre><code class=\"language-rs\">struct Point&#x3C;T, U> {\r\n    x: T,\r\n    y: U,\r\n}\r\n\r\nfn main() {\r\n    let a = Point {x: 1, y: 1.5};\r\n    let b = Point {x: 1.5, y: 1};\r\n    let c = Point {x: 1, y: 1};\r\n    let d = Point {x: 1.5, y: 1.5};\r\n}\n</code></pre>\n<p>and same goes for enums as well.</p>\n<pre><code class=\"language-rs\">enum Option&#x3C;T> {\r\n    Some(T),\r\n    None,\r\n}\n</code></pre>\n","tags":["Rust","Programming-Language"]}},"__N_SSG":true}