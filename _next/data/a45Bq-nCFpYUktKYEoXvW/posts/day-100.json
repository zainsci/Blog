{"pageProps":{"post":{"title":"Day 100 - Loading And Linking","date":"2021-04-10","slug":"day-100","content":"<p>Now we know how a program is translated and binded from logical address to physical addresses in the main memroy. Today's topic is going to be how a program is loaded and linked for exection.</p>\n<p>Following are the ways by which the program loading is performed.</p>\n<h3>Absolute Loading</h3>\n<p>An absolute loader loads the load-module into the memory as it is. It makes no changes to the logical addresses assigend by the translator and assumes that the translator or the programmer has already assigned the correct addresses. With this approcah the load module must always occupy the same space in the main memory as it does in the disk storage. This approach to loading is never used.</p>\n<h3>Re-Locatable Loading</h3>\n<p>In Re-Locateable Loading, the loader adds an ofset to all the logical addresses while copying the module in the main memory. This type of loader wants the translator the generate relative addresses. It is also necessary for the program to be loaded into the consecutive memroy and the physical addresses are found by adding <strong>M</strong> in front to each relative address.</p>\n<p>In this case the addresses are bound at run time rather than at build time. It is a more flexible approach the complie time binding. The program can be loaded into separate set of locations everytime it runs. Re-Locateable Loading provides more multiprogramming than absolute loading. In absolute loading the programs that have the same address cannot run at the same time while re-locatable loading does not have this problem which makes it easier for programmers because they don't have to tell where to store every instruction.</p>\n<h3>Dynamic Loading (Dynamic Relocation)</h3>\n<p>Re-locatable loading does not support swapping which means that once a process is swapped out from the memory it cannot be reloaded into the memory and have the same addresses as it had previously. Once a process is loaded and relocated in the memory it becomes absolute.</p>\n<p>Dynamic Loading defers the process of determining absolute addresses until the address is used. The loader places the the load module into the memroy without adjusting relative addresses. A special register is loaded with the start address of the module. Hardware automatically adds the register contents to a relative address each time the address is used. In this case, address binding is at runtime and relocation is done each time the address is used.</p>\n<h3>Linking</h3>\n<p>A linker joins many modules to form a single load module. Linker takes load modules as input. Each module is translated with relative addresses, relative to 0 as the start address of the module. References to other modules such as function and variables are still symbolic. A linker must create a single module in which all the external references are resolved. The term <strong>Linkage Editor</strong> is applied to this type of linker.</p>\n<p>The Linker postpones some of the linkage functions until the run time. Dunamic linking can be done at load time or at run time. Load-time dynamic linking creates a relocateable module in a normal way. It leaves some external references unresolved. There references are usually to the system utilites or language libraries. The system copies of the linked modules can be linked at the load time. The utilites can be changed without forcing the programmers to re-link existing modules. A shared code can be linked to more than one program. Run-time dynamic linking goes a step futhur. Some modules are not linked in until they are actually called.</p>\n","tags":["Operating-Systems"]}},"__N_SSG":true}