{"pageProps":{"post":{"title":"Day 55 - Quick Sort","date":"2021-02-24","slug":"day-55","content":"<p>This is the fifth post in the Data Structures and Algortihms today I will be learning about another sorting algorithm called Quick Sort. Quick Sort is another sorting algorithm just like the Merge Sort that is based on divide and conquer technique. Quick sort is faster than some other sorting algorithms like Merge sort and Heap Sort. It is one of the most popular and most implemented sorting algorithm in the world.</p>\n<div style=\"display: flex; flex-direction: column; align-items: center;\">\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"Quick Sort Animation\"></p>\n<div style=\"font-size: 10px; text-align: center;\">\n<p>Image Courtesy: <a href=\"https://en.wikipedia.org/wiki/Quicksort#/media/File:Sorting_quicksort_anim.gif\">Wikipedia</a></p>\n</div>\n</div>\n<p>Quick Sort uses partition just like Merge Sort uses merge to sort the list. Partition is a way of separating list of elements around a single element. Let this element be \"x\". This algorithm will separate elements such that the elements on the left are smaller than x and the elements on the right are bigger than x.</p>\n<pre><code class=\"language-py\">nums = [4, 3, 2, 5, 6, 9, 8, 7, 1, 0]\r\n\r\npartition(nums, pivot, low, high)\r\n# [1, 0, 3, 2, 4, 5, 6, 9, 8, 7]\r\n#      This is ^ Pivot\r\n# [1, 0, 3, 2] smaller than pivot\r\n# [5, 6, 9, 8, 7] larger than pivot\n</code></pre>\n<p>Now we can see how Quick Sort works.</p>\n<h3>How Quick Sort Works?</h3>\n<p>Quick Sort works by selecting a single element as a pivot and sort all other elements according to the pivot such that every element that is smaller than the pivot is placed on the left side of the pivot element and every element that is bigger than the pivot is placed on the right side of the pivot element.</p>\n<p>This forms a list where every element on the left of pivot is smaller than the pivot and every element on the right side of the pivot is bigger than the pivot after that it runs recursively on the left side of the list and on the right side of the list to sort those sides and then thier smaller lists and so on and on until the whole list is sorted.</p>\n<pre><code class=\"language-py\">1. [4, 3, 2, 5, 6, 9, 8, 7, 1, 0]\r\n2. [[3, 2, 1, 0], 4, [5, 6, 9, 8, 7]]\r\n3. [[[2, 1, 0], 3], 4, [5, [6, 9, 8, 7]]]\r\n4. [[[1, 0], 2], 3], 4, [5, [6, 9, 8, 7]]]\r\n5. [[[[0], 1], 2], 3], 4, [5, [6, [9, 8, 7]]]]\r\n6. [[[[0], 1], 2], 3], 4, [5, [6, [7, [9, 8]]]]]\r\n7. [[[[0], 1], 2], 3], 4, [5, [6, [7, [8, [9]]]]]]\r\n8. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>In most of the implementations the first element of the list is selected as the pivot element but you can also selec pivot as:</p>\n<ul>\n<li>The last element of the list</li>\n<li>Random element from the list</li>\n<li>Some element that is already in the sorted position</li>\n</ul>\n<h2>Complexity</h2>\n<p>Quick Sort is a very efficient algorithm for sorting a large sets of data with only having the time complexity of <strong>O(n^2)</strong> in the <strong>Worst Case</strong>. In <strong>Best Case</strong> it has a time complexity of <strong>O(n*log(n))</strong> and the same goes for the <strong>Average Case</strong>.</p>\n","tags":["Data-Structures","Algorithms"]}},"__N_SSG":true}