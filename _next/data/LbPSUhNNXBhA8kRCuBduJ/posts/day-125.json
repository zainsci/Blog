{"pageProps":{"post":{"title":"Day 125 - Hash Maps In Rust","date":"2021-05-05","slug":"day-125","content":"<p>Last time we looked at Vectors which are like fixed size arrays as in C but with much more functionality and today we will look at another data structure called Hash Maps in Rust. Python have Dictionaries and JavaScript have Objects that are the same as Hash Maps.</p>\n<h2>Hash Maps</h2>\n<p>Hash Map is a Data Structure that store a value that is associated with a key in the Hash Map. This key can then later be used to access the value that is relative to that key. The type <code>HashMap&#x3C;K, V></code> store the key of type <code>K</code> and the value of type <code>V</code>.</p>\n<p>Under the hood, Hash Maps use a hashing function to determine how to place these value and keys into the memory. These can be useful when we want to store and retrive data not with an index like numbers but instead with keys. Keys can be anything from numbers to strings etc.</p>\n<h3>Creating A Hash Map</h3>\n<p>A new Hash Map can be created using the <code>new()</code> method and values can be added to it later in the code. But before doing that we have to <code>use</code> the <code>HashMap</code> from the <code>collections</code> part of the standard library.</p>\n<pre><code class=\"language-rs\">use std::collection::HashMap;\r\n\r\nfn main() {\r\n    let mut marks = HashMap::new();\r\n}\n</code></pre>\n<p>To add values to it we use <code>insert</code> method.</p>\n<pre><code class=\"language-rs\">marks.insert(String::from(\"Tom\"), 70);\r\nmarks.insert(String::from(\"Jerry\"), 90);\n</code></pre>\n<h3>Accessing Values From A HashMap</h3>\n<p>To access values from a HashMap we use get method on the hashmap with key as the argument to the get method.</p>\n<pre><code class=\"language-rs\">marks.get(String::from(\"Tom\")).unwrap(); // 70\n</code></pre>\n<p>Acessing the value from a HashMap has to be done with very carefully as if provided with the keythat does not exist the program will panic. When we call a get method, the HashMap will return the value of type of either <code>Some</code> or of type <code>None</code>.</p>\n<p>Here the return type of the <code>marks.get</code> is of <code>Some</code> type. and to get the value we then use the <code>unwrap</code> method. This is where the problem is. If we call the <code>unwrap</code> method on value of type <code>None</code> the program will panic and crashes. To deal with this we can use conditional statements here.</p>\n<pre><code class=\"language-rs\">if marks.contains_key(\"Tom\") {\r\n    let toms_marks = marks.get(\"Tom\");\r\n\r\n    match toms_marks {\r\n        x if x &#x3C; 35 => println!(\"Failed\"),\r\n        x if x &#x3C; 70 => println!(\"Pass\"),\r\n        _ => println!(\"Excellent\")\r\n    }\r\n}\n</code></pre>\n<h3>Ownership In HashMaps</h3>\n<p>When working with HashMaps we must take that in mind that the Ownership here works the same as anywhere else in Rust. For types with <code>Copy</code> trait, there is no need to worry. But for owned values like <code>String</code> when we use the value in HashMap, the HashMap will take the ownership for that value.</p>\n<p>Consider the following example from the Official Documentation.</p>\n<pre><code class=\"language-rs\"> use std::collections::HashMap;\r\n\r\nlet field_name = String::from(\"Favorite color\");\r\nlet field_value = String::from(\"Blue\");\r\n\r\nlet mut map = HashMap::new();\r\nmap.insert(field_name, field_value);\r\n// field_name and field_value are invalid at this point, try using them and\r\n// see what compiler error you get!\n</code></pre>\n","tags":["Rust","Programming-Language"]}},"__N_SSG":true}